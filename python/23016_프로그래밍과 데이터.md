# 23016_프로그래밍과 데이터

# 프로그래밍(programming)

> 소프트웨어를 개발하기 위한 과정 ⇒ 컴퓨터에게 일시키는 도구
컴퓨터에 명령하는 적절한 수행 절차를 정의하고 이를 프로그래밍 언어로 표현하는 과정. 
코딩(coding)의 다른 표현.
> 
1. 컴퓨터에게 시키고 싶은 일을 정함.
    1. 계산(computation), 저장, 반복
2. 컴퓨터가 이해할 수 있도록 수행 절차를 정의해서 표현
3. 적절한 프로그래밍 언어(효율적)를 선택 및 언어를 이용해 절차 기술.
4. **발생하는 오류 수정**
    1. 구문 오류(syntax error) : 문법 x  실행 x
    2. 논리 오류(semantic error) : 문법 o 실행 o 결과 x

소스코드 : 프로그래밍 언어로 작성된 프로그램

## ⭐Computational Thinking(컴퓨팅 사고력)

> 컴퓨터가 효과적으로 수행할 수 있도록 문제를 정의하고 그에 대한 답을 기술하는 것이 포함된 사고 과정 일체
> 

1. 컴퓨터의 특성을 잘 이해한다.  *understanding computer*
2. 문제 해결 능력을 기른다.  *problem solving, 논리적 사고 == 작은 문제로 쪼개기*
3. 프로그래밍 언어에 능숙해진다.  *trial & error 무한반복!*

 그냥 하면 된다 just do it

# Python 시작하기

**프로그래밍 언어**

> 컴퓨터는 기계어(0, 1)로 소통한다.
기계어의 대안으로 사람이 이해할 수 있는 새로운 언어를 개발
> 
- 사람이 이해할 수 있는 문자로 구성
- 기본적인 규칙과 문법이 존재

**번역기(interpreter/compiler)**

- 소스 코드를 컴퓨터가 이해할 수 있는 기계어로 번역
- 파이썬의 경우 인터프리터를 사용/  한 줄 씩 바로 실행할 수 있음

**파일로 실행하기**

.py 라는 확장자를 가진 파이선 파일 작성(메모장)

`python {실행할 파이썬 파일 이름}.py`

**VS Code**

- 메모장인데 개발에 편한 기능 들어 있다.
- 확장프로그램을 통해 더 많은 기능 부착해서 나만의 개발 환경을 만들 수 있다.

**파이썬 개발 환경 종류**

- IDE : 통합 개발 환경. 개발에 필요한 다양하고 강력한 기능이 있다. (vs code, 파이참)
- Jupyter Notebook
- IDLE

- 코딩 : 파이썬
- 웹 : vs code
- 알고리즘 : 파이참

# ⭐Python 기본문법

### 1. 변수(Variable)

> 메모리의 주소를 기억. 우리는 변수를 통해 테이터를 기억한다.
> 
- 추상화(복잡 ⇒ 간단)
    - 코드의 가독성 증가
    - 숫자를 의미 단위로 작성 가능
    - 코드 수정 용이
- 동일 변수에 다른 데이터를 언제든 할당(저장)할 수 있기 때문에, ‘변수’라고 불린다.
- 할당
    - 할당 연산자(=)
    - 같은 값 동시에 할당 가능
    - 다른 값 동시에 할당 가능

### 2. 식별자(identifiers)

> 변수의 이름(변수, 함수, 클래스…)
읽기 쉽고 이해하기 쉬운 변수명이 최고
> 

규칙

- 식별자의 이름은 영문 알파벳, 언더스코어(_), 숫자로 구성
- 첫 글자에 숫자가 올 수 없음
- 길이 제한이 없고, 대소문자를 구별
- 다음의 키워드(keywords)는 예약어(reserved words)로 사용할 수 없음
- 내장 함수나 모듈 등의 이름도 사용하지 않아야 함/ 동작을 예상할 수 없게 임의로 값을 할당하게 되므로 범용적이지 않은 코드가 된다.

### 3. 주석

> 코드의 실행에 영향을 미치지 않는 나만의 메모
*주석 다는 습관을 들이자*
> 
- 코드에 대한 쉬운 이해
- 유지 보수 용이
- 협업 용이
- 프로그램 실행에는 전혀 영향 x

### 4. 연산자

산술 연산자(Arithmetic Operator)

| + | 덧셈 |
| --- | --- |
| - | 뺄셈 |
| * | 곱셈 |
| / | 나눗셈 |
| // | 몫 |
| % | 나머지 |
| ** | 거듭제곱 |

우선순위 같음

---

### 5. 자료형(Data type)

> **데이터 10을 컴퓨터가 기억하는 과정**
> 
1. 10을 저장할 공간을 메모리에 만들고
2. 저장할 공간에 대한 주소를 할당받는다
3. **할당 받은 주소를 기억했다가 (1324658434)  #주소값을 기억하기 힘들다 ⇒ ‘변수’ 사용/ 변수 ⇒ 메모리의 주소를 기억하는 이름**
4. 10이라는 데이터를 해당 주소로 찾아가서 저장한다
5. 이후에 10이 필요해지면 해당 주소로 가서 읽어온다

자료형마다 차지하는 메모리의 크기가 다르다 ⇒ 이걸 정한 것.  data type.

`id(보고싶은 변수 값)` : 실제 주소값이 어떻게 되는지 알고 싶다면

### 1) 수치형(Numeric type)

- 정수 자료형(int)
    - 여러 진수 표현 가능
        - 2진수 0b
        - 8진수 0o
        - 16진수 0x
- 실수 자료형(float)
    
    정수를 이진수로 변환하는 건 쉽다. 하지만 소수라면?
    소수는 끝이 없다. 
    
    실수 연산시 주의할 점 ⇒ 부동 소수점을 사용한다.  (여기까지 알아 놓기)
    
    값 비교하는 과정에서 정수가 아닌 실수면 주의할 것. 매우 작은 수보다 작은지를 확인하거나  math 모듈 활용
    

### 2) 문자열(String type)

> 모든 문자는 str 타입
`’` `"` 활용하여 표기
> 

PEP8에서는 소스코드 내에서 하나의 문장부호를 선택하여 유지하도록 함.

- 중첩 따옴표 : ‘ , “ 번갈아가며 사용 가능
- 삼중 따옴표 : 삼중으로 사용, 여러 줄 나눠 입력할 때 편리. 엔터까지 저장, 주석달때 사용

**Escape sequence : 컴퓨터를 문자로 제어하기 위해 만들어짐, 제어 시퀀스**

| \n  ** |  줄바꿈(엔터) |
| --- | --- |
| \t  ** | 탭 |
| \r | 캐리지 리턴 |
| \0  ** | 널(Null) |
| \\ | \ |
| \’ | 단일인용부호(’) |
| \’’ | 이중인용부호(”) |

```python
print(aaaaa\rbbb)  # \r 캐리지 리턴

bbbaa
```

- **f-strings : `print(f'{})`**

### 3) none

> 값이 없음을 표현
일반적으로 반환 값이 없는 함수에서 사용하기도 함
> 

### 4) 불린(Boolean type)

> 논리 자료형으로 참과 거짓 표현
True or False를 값으로 가짐
비교 / 논리 연산에서 활용됨
> 

| ==  | 같음/ value  값 |
| --- | --- |
| != | 같지 않음 |
| is | 객체 아이덴티티(OOP)/ object(객체) 자체를 비교 |
| is not | 객체 아이덴티티가 아닌 경우 |

```python
a = []  
b = []
c = a  # c에 a의 주솟값을 준것.(참조)

print(id(a))
print(id(b))
print(id(c))   # a와 c의 주솟값이 같다는 것을 알 수 있다.

result = (a is b)
print(result)

result = (a is c)
print(result)

result = (b is c)
print(result)

False
True     #참조하기 때문에 true.
False

----------------------------------
b = []
if not b :
	print('b는 비었습니다.')
# 빈 리스트는 false
# 0 도 false

if 조건 1 and 조건 2:
-----------------------------------
if not True:    # true면 false, false면 true

result = True # 회원이 인증된 상태

if not result:
	print('회원 인증을 해주세요')

---------------------------------
#주의할 점
 falsy : 빈 문자열
#우선순위 존재 not and or
```

 단축 평가

- 결과과 확실한 경우 1 반환
- and 연산에서 1 false → false
- or 연산에서 1 true → true

<aside>
💡 어떤 자료형을 언제??
1. 개발자의 선택
2. 문제의 성격

</aside>

---

## ☑️ 컨테이너

> 여러 개의 값(데이터)을 담을 수 있는 것(객체)으로, 서로 다른 자료형을 저장할 수 있음/모아서 관리하겠다.
> 

- 시퀀스형 : 순서가 있는 데이터
    - 리스트(**가변형**)
    - 튜플(**불변형**)
    - 레인지(불변)
- 비시퀀스형 : 순서가 없는 데이터
    - 세트(가변)
    - 딕셔너리(가변)
    
    순서가 있다 ≠ 정렬되어 있다.
    

### 1. 시퀀스형

**리스트**

> 여러개의 값을 순서가 있는 구조로 저장하고 싶을 때 사용
> 

```python
# list
list_a = []  # 대괄호로 선언/값을 담아도 되고 안담아도 됨
list_b = [1, 2, 3] # 값 담았다/ 중첩되지 않는 1차원 리스트
list_c = list()  # 생성자 사용

# 유연성
list_d = [1, 2, 3, 'python', ['']]  # 다양한 자료구조 한번에 담을 수 있다.
       #     0          1                2
list_e = [[1,2,3],['python'],['서울','대전','부울경','구미']]  #2차원
       #   0 1 2      0          0     1      2       3
print(list_e[0]) = [0, 1, 2]
print(list_e[0][2]) = 3
-----------------------------------------------------
# 실습

boxes = ['A', 'B', ['apple', 'banana', 'cherry']]

print(len(boxes))  # 3
print(boxes[2])    # ['apple', 'banana', 'cherry']
print(boxes[2][-1])   # cherry / -1은 가장 마지막 값
print(boxes[-1][1][0]) # b / string도 반복문이 가능하다.
--------------------------------------------------------
```

**튜플**

> 여러 개의 값을 순서가 있는 구조로 저장하고 싶을 때 사용
생성 후 담고 있는 값 변경 불가(불변 자료형) - 실수로라도 값을 변경하면 안될 때 사용
> 

```python
# ()소괄호 혹은 tuple()을 통해 생성
# 수정 불가능한 시퀀스로 인덱스로 접근 가능
# 값에 대한 접근은 my_tuple[i]

tuple_a = (1,)  # 단일 항목의 경우 , 붙어야 함
tuple_b = (1, 2, 3,) #복수 항목의 경우 없어도 되지만 권장

```

**Range**

> 숫자의 시퀀스를 나타내기 위해 사용
주로 반복문과 함께 사용됨
> 

```python
# 기본형 range(n) 0 ~ n-1까지
  

# 범위 지정 range(n, m) n ~ m-1까지

# parameter = 함수에게 전달해주는 값 (input)
							# 1에서 시작 5까지

print(list(range(1, 10, 2)))
[1, 3, 5, 7, 9]  #1~9에서 2씩 증가

# 역순
print(list(range(6, 1, -1)))  #[6, 5, 4, 3, 2, 1]

 
```

**슬라이싱 연산자**

> 시퀀스를 특정 단위로 슬라이싱
인덱스와 콜론을 사용하여 문자열의 특정 부분만 잘라낼 수 있다.
슬라이싱을 이용하여 문자열을 나타낼 때 콜론을 기준으로 앞 인덱스에 해당하는 문자는 포함되지만 뒤 인덱스에 해당하는 문자는 미포함
> 

```python
# 슬라이싱

# 리스트
print([1, 2, 3, 4][0:4:2])  # 첫번째 포함, 2씩 증가 [1, 3]

# 튜플
print((1, 2, 3, 4, 5,)[0:4:2]) # (1, 3)  #? 3뒤에 쉼표는 필요 없나

# 문자열
print('abcdefg'[1:4]) # bcd 

# range

# 시퀀스 생략
a = ['a', 'b', 'c', 'd', 'e', 'f']
# a[시작: ] => 특정 인덱스 부터 끝까지 가져오기.
# a[ :끝] => 시작부터 특정 인덱스까지 가져오기.
```

### 2. 비시퀀스형

**딕셔너리**

> 키(key)-값(value) 쌍으로 이뤄진 자료형
> 

- 키(key) : 변경 불가능한 데이터만 활용 가능(string, integer, float, boolean, tuple, range)/ 중복으로 가질 수 없다.
- 값(values) : 어떤 형태든 관계 없다.

```python
dict_a = {}
dict_b = dict()

dict_a = {'a' : 'apple', 'b' : 'banan', 'list' : [1, 2, 3]}
----------------------------------------------------------------
# 없는 키 값에 접근
print(dict_a['c'])  #KeyError : 'c' / 에러에 대한 처리를 해야 한다.
result = dict_a.get('c') # errorx 매칭되는 key값이 없기 때문에 none 반환

if not result:           # none을 처리할 수 있는 로직을 넣을 수 있다.
	print('값 없음.')

# 딕셔너리의 value를 가져올 때 리스트나 튜플 이용.

```

**형 변환(Typecasting)**

> 데이터 형태는 서로 변환할 수 있다.
> 
- 암시적 형 변환(Implicit)
    - 사용자가 의도하지 않고, 파이썬 내부적으로 자료형 변환
    - bool, Numeric Type(int, float)

```python
print(True + 3) #4
print(3 + 5.0) #8.0 알아서 변환되어 값 추출한다.
```

- 명시적 형 변환(Explicit)    >> 우리가 추구해야 할 것.
    - int : str, float ⇒ int   / 형식에 맞는 문자열만 정수로 변환 가능
    - float
    - str

**컨테이너 형 변환**